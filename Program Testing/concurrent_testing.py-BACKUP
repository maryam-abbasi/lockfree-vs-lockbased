import os
import time
from threading import Thread, current_thread, Condition, Lock
from multiprocessing import Process, Queue, freeze_support, cpu_count

def IsWinOS():
    if os.name == "nt":
        freeze_support()
        print("Freeze Support Enabled Because of Windows Operating System.")
    else:
        print("Freeze Support Not Enabled Because of a Non Windows Operating System.")

class MultiThread:
    def __init__(self):
        self.thread_1 = None
        self.thread_2 = None

    def firstTry(self):
        print(f"[{current_thread().name}] First Try Thread Running.")
        return None

    def secondTry(self):
        print(f"[{current_thread().name}] Second Try Thread Running.")
        return None

    def createThreads(self):
        self.thread_1 = Thread(target=self.firstTry, name="Thread First Try")
        self.thread_2 = Thread(target=self.secondTry, name="Thread Second Try")

        self.thread_1.start()
        self.thread_2.start()

        self.thread_1.join()
        self.thread_2.join()

        print("All Threads Finished Successfully.")

class MultiProcess:
    def __init__(self):
        self.process_1 = None
        self.process_2 = None
        self.processes = []
        self.max_processes = cpu_count()
        print(f"Number of CPUs Available: {self.max_processes}")

    def firstTry(self):
        print(f"[{os.getpid()}] First Try Process Running.")
        return None

    def secondTry(self):
        print(f"[{os.getpid()}] Second Try Process Running.")
        return None

    def createProcesses(self):
        self.process_1 = Process(target=self.firstTry)
        self.process_2 = Process(target=self.secondTry)

        self.process_1.start()
        self.process_2.start()

        self.process_1.join()
        self.process_2.join()

        print("All Processes Finished Successfully.")

    def worker(self, index):
        print(f"[PID {os.getpid()}] Process {index} Started.")
        time.sleep(1)
        print(f"[PID {os.getpid()}] Process {index} Finished.")

    def createProcessesBETA(self):
        print(f"Creating {self.max_processes} Processes (1 per CPU).")
        for i in range(self.max_processes):
            p = Process(target=self.worker, args=(i + 1,))
            self.processes.append(p)
            p.start()

        for p in self.processes:
            p.join()

        print("All Processes Have Been Finished.")

class QueueBased:
    def __init__(self, max_size=None):
        self.queue = []
        self.max_size = max_size
        self.lock = Lock()
        self.not_empty = Condition(self.lock)
        self.not_full = Condition(self.lock)
    
    def put(self, item, block=True):
        """Adiciona um item à fila"""
        with self.lock:
            if self.max_size is not None:
                while len(self.queue) >= self.max_size:
                    if not block:
                        raise Queue.Full()
                    if not self.not_full.wait(None):
                        raise Queue.Full()
            
            self.queue.append(item)
            self.not_empty.notify()
            return True
    
    def get(self, block=True):
        """Remove e retorna um item da fila"""
        with self.lock:
            while len(self.queue) == 0:
                if not block:
                    raise Queue.Empty()
                if not self.not_empty.wait(None):
                    raise Queue.Empty()
            
            item = self.queue.pop(0)
            if self.max_size is not None:
                self.not_full.notify()
            return item
    
    def qsize(self):
        """Retorna o tamanho atual da fila"""
        with self.lock:
            return len(self.queue)
    
    def empty(self):
        """Verifica se a fila está vazia"""
        with self.lock:
            return len(self.queue) == 0
    
    def full(self):
        """Verifica se a fila está cheia"""
        if self.max_size is None:
            return False
        with self.lock:
            return len(self.queue) >= self.max_size


if __name__ == "__main__":
    IsWinOS()
    MultiThread().createThreads()    
    MultiProcess().createProcesses()